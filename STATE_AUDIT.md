# State Management Audit

> Generated by automated audit of all pages, components, stores, and libs.

## Executive Summary

The app is **mostly migrated** to the new `useRecordsStore` (Zustand). The old `useSessionStore` in `session.ts` has **zero runtime imports** from any page or component — it is dead code. The remaining flicker/state issues come from:

1. **ProviderSelectPage** — a fully `useState`/`useEffect` page that fetches vendor configs + brand data outside the store
2. **OAuthCallbackPage** — duplicates `statusMessage` with local `useState`, causing split-brain between store and local state
3. **ProviderSelectPage** directly calls `loadSession()` from `lib/storage.ts` (the old persistence layer) instead of getting session info from the store
4. **ConnectPage** has a potential double-load race (calls `loadConnections()` inside `.then()` after `initSession`, while `RecordsPage` also calls `loadConnections` in its own `useEffect`)

---

## 1. Summary Table

| File | Store Used | Local useState | useEffect | Flicker Risk | Action Needed |
|------|-----------|---------------|-----------|-------------|---------------|
| **store/records.ts** | ✅ IS the store | — | — | — | None (this is the source of truth) |
| **store/session.ts** | ⚠️ OLD store | — | — | — | **DELETE** — zero imports from any page/component |
| **RecordsPage.tsx** | ✅ `useRecordsStore` | None | 1 (load guard) | Low — shows "Loading…" until `loaded=true` | Minor: empty deps `[]` on useEffect |
| **ConnectPage.tsx** | ✅ `useRecordsStore` | None | 1 (init session) | Medium — double-load race | Fix: remove redundant `loadConnections()` |
| **OAuthCallbackPage.tsx** | ✅ `useRecordsStore` | 3 (`errorMsg`, `localStatus`, `done`) | 1 (OAuth flow) | **HIGH** — split-brain status | Migrate local status to store |
| **ProviderSelectPage.tsx** | ❌ None | 8 useState calls | 1 (big init) | **HIGH** — full page of local state | Partially justified (ephemeral UI) but vendor configs should be store-level |
| **HomePage.tsx** | ❌ None | 2 (`copied`, `showHelp`) | 0 | None | Fine — purely local UI state |
| **App.tsx** | ❌ None | 0 | 0 | None | Fine — just routing |
| **StatusMessage.tsx** | ❌ None | 0 | 0 | None | Fine — pure presentational |
| **ProviderSearch.tsx** | ❌ None | 1 (`value`) | 1 (debounce) | None | Fine — local input state |
| **ProviderCard.tsx** | ❌ None | 0 | 0 | None | Fine — pure presentational |
| **lib/storage.ts** | — (persistence) | — | — | — | Partially dead — OAuth helpers still used |
| **lib/connections.ts** | — (persistence) | — | — | — | Active — used by records store |
| **lib/api.ts** | — (API client) | — | — | — | Active — used by records store |

---

## 2. Detailed Findings Per File

### store/records.ts — ✅ THE canonical store

**State managed:** connections, connectionState (per-connection transient UI), selected (Set), session context, global status/statusMessage/error, loaded flag.

**Actions:** loadConnections, initSession, clearSession, toggleSelected, selectAll, selectNone, refreshConnection, removeConnection, saveNewConnection, sendToAI, finalizeSession (no-op), downloadJson, setError, clearError.

**Verdict:** Well-designed. This store IS the single source of truth for connections, session context, and global status. No issues.

---

### store/session.ts — ☠️ DEAD CODE

**Imports analysis:**
- `useSessionStore` is exported but **never imported** by any page, component, or other file.
- It imports from `lib/storage.ts` (the old `localStorage`/`sessionStorage` persistence layer).
- Its state model (`SessionState`) overlaps with `RecordsState.session` — it tracks `sessionId`, `publicKeyJwk`, `finalizeToken`, `providers`, `finalized`, `status`, `error`.

**Verdict:** 100% dead. Delete entirely.

---

### RecordsPage.tsx (lines 1–218)

**Store usage:** `useRecordsStore()` — full store reference (line 25). Uses: `s.session`, `s.status`, `s.selected`, `s.connections`, `s.loaded`, `s.connectionState`, `s.error`, `s.statusMessage`, `s.loadConnections`, `s.selectAll`, `s.selectNone`, `s.toggleSelected`, `s.refreshConnection`, `s.removeConnection`, `s.clearError`, `s.sendToAI`, `s.downloadJson`.

**Local state:** None.

**useEffect (line 34):**
```ts
useEffect(() => { if (!s.loaded) s.loadConnections(); }, []);
```
- Guard: only loads if `!s.loaded`. Good.
- Issue: empty deps `[]` but references `s.loaded` and `s.loadConnections`. React lint would warn, but functionally it's correct because `loaded` starts as `false` and is set to `true` once.

**Initial render:** Shows `<StatusMessage status="loading" message="Loading…" />` until `s.loaded` is true. No flicker — the loading state is explicit.

**Problems:**
1. **(Minor, line 34)** Empty dependency array references store values. Not a bug because `loadConnections` is stable, but linting will complain.
2. **(Minor, line 25)** `const s = useRecordsStore()` subscribes to the ENTIRE store. Any state change re-renders the whole page. Should use selectors for performance.

---

### ConnectPage.tsx (lines 1–77)

**Store usage:** `useRecordsStore()` — uses `store.session`, `store.status`, `store.error`, `store.initSession`, `store.loadConnections`.

**Local state:** None.

**useEffect (lines 18–31):**
```ts
useEffect(() => {
  if (!sessionId) return;
  if (!store.session || store.session.sessionId !== sessionId) {
    store.initSession(sessionId).then(() => {
      store.loadConnections(); // <-- PROBLEM
    });
  }
}, [sessionId]);
```

**Problems:**
1. **(Medium, line 23)** `store.loadConnections()` is called BOTH here (after initSession) AND in RecordsPage's useEffect (line 34). Since ConnectPage renders RecordsPage as a child, both fire. The second call is guarded by `if (!s.loaded)` so it's a no-op IF the first call already set `loaded=true`. But there's a race: if `ConnectPage`'s `.then()` fires after RecordsPage has already mounted and started its own load, you get two concurrent `loadConnections()` calls. This causes:
   - Double IndexedDB reads
   - Possible state thrashing (second call overwrites first call's result)
   - The `loaded` flag prevents the second call in RecordsPage only if the first is already complete.

2. **(Minor, line 21)** References `store.session` in the condition but `store` is not in the dependency array. On re-renders with a new `sessionId`, the stale closure could see old `store.session`.

3. **(Minor, line 34)** `searchParams.get('provider_added')` drives a success flash via a fixed `<div>` at `top:0` (line 70). This banner never auto-dismisses — it stays until the URL changes.

**Initial render:** Shows "Loading session…" spinner until `store.session` is populated. If `initSession` fails, shows error. No flicker for the happy path.

---

### OAuthCallbackPage.tsx (lines 1–140) — **HIGHEST FLICKER RISK**

**Store usage:** `useRecordsStore()` — uses `store.saveNewConnection`, `store.statusMessage`.

**Local state (3 pieces):**
- `errorMsg` (line 25) — local error string
- `localStatus` (line 26) — local status message, starts as `'Completing authorization…'`
- `done` (line 27) — boolean flag for completion

**useEffect (lines 33–112):** Single large effect that:
1. Guards against double-execution (StrictMode + module-level `processingStates` Set)
2. Reads OAuth state from `sessionStorage` via `loadOAuthState(stateNonce)`
3. Calls `exchangeCodeForToken`
4. Calls `store.saveNewConnection` (which updates `store.statusMessage` with fetch progress)
5. Sets `done=true`, then navigates away

**Split-brain status (lines 115–117):**
```ts
const storeProgress = store.statusMessage;
const displayStatus = storeProgress || localStatus;
```
This merges `store.statusMessage` with `localStatus`. The problem:
- `localStatus` starts as `'Completing authorization…'`
- After `exchangeCodeForToken`, `localStatus` is set to `'Fetching health records…'`
- BUT `store.saveNewConnection` also sets `store.statusMessage` to `'Fetching health records…'` then `'Fetching: ...'`
- The `||` operator means `storeProgress` wins when non-empty, but when the store briefly clears `statusMessage` (e.g., on status transitions), `localStatus` bleeds through with stale text.

**Flicker scenario:**
1. OAuth exchange starts → shows "Completing authorization…" (local)
2. `saveNewConnection` begins → store sets status to `'loading'`, `statusMessage` to `'Fetching health records…'` → display shows store message ✓
3. Store updates progress → display shows "Fetching: Patient (3/15)" ✓
4. `saveNewConnection` completes → store sets status to `'idle'`, `statusMessage` to `''` → **display falls back to stale `localStatus` = "Fetching health records…"** ← WRONG
5. Then `setDone(true)` fires and `setLocalStatus('Done! Redirecting…')` → brief flash of correct text
6. Navigation happens

Step 4 is the flicker: for one render frame, the user sees stale "Fetching health records…" between the store completing and local state updating.

**Problems:**
1. **(HIGH, lines 25–27, 115–117)** Split-brain status between store and local state. The local `errorMsg`, `localStatus`, and `done` should be part of the store or derived from it.
2. **(Medium, line 4)** Imports `loadOAuthState`/`clearOAuthState` from `lib/storage.ts`. This is the OLD persistence layer. The OAuth state data is inherently transient (used once after redirect), so it's defensible to keep in `sessionStorage`. But it means two persistence mechanisms are in play.
3. **(Minor)** The `startedRef` + `processingStates` double-guard is complex but necessary for StrictMode. No change needed.

---

### ProviderSelectPage.tsx (lines 1–300) — **MOST LOCAL STATE**

**Store usage:** ❌ None. Does not import any store.

**Local state (8 pieces):**
- `loadProgress` (line 27) — tracks brand file loading phase
- `error` (line 28) — error string
- `page` (line 31) — pagination
- `allItems` (line 34) — full brand list (can be 50k+ items)
- `vendors` (line 35) — vendor config map
- `searchResults` (line 36) — filtered results
- `query` (line 37) — search input
- `selectedItem` (line 44) — modal state
- `connecting` (line 45) — OAuth redirect in progress

**useEffect (lines 48–91):** Large init effect that:
1. Fetches vendor configs via `getVendorConfigs()` API call
2. Loads brand files for each vendor
3. Sets all items + search results

**Problem: Direct `loadSession()` call (line 155):**
```ts
const session = loadSession();
saveOAuthState(state, {
  sessionId: effectiveSessionId,
  publicKeyJwk: session?.publicKeyJwk || null,
  ...
});
```
This reads from `localStorage` directly (the old persistence layer) instead of getting `publicKeyJwk` from `useRecordsStore().session`. In the new architecture, the records store's `session.publicKeyJwk` is the source of truth. If the store has it but `localStorage` doesn't (or vice versa), the OAuth state will have the wrong public key.

**Flicker scenarios:**
1. **(Medium)** Every time you navigate to this page, the entire brand file (~5MB) is re-fetched and re-parsed because the data lives in local state. If this were in the store, returning to this page would show cached results instantly.
2. **(Low)** The `useEffect` has `[sessionId]` as deps (line 91), so changing the session ID in the URL re-triggers the full load. This is correct but slow.

**Verdict on local state:** Most of this state is legitimately ephemeral (search query, pagination, modal state). However:
- `vendors` (vendor configs) should be in the store — they're global app config
- `allItems` (brand list) could be cached in the store to avoid re-fetching on every page visit
- The `loadSession()` call is a bug — should read from `useRecordsStore`

---

### HomePage.tsx (lines 1–146)

**Store usage:** None.

**Local state:**
- `copied` (line 9) — clipboard feedback, auto-resets after 2s
- `showHelp` (line 10) — accordion toggle

**Verdict:** ✅ Perfect. This is purely local UI state with no data fetching. No changes needed.

---

### App.tsx (lines 1–32)

**Store usage:** None.
**Local state:** None.
**useEffect:** None.

**Observation:** There is no top-level store initialization. No `useEffect` calls `loadConnections()` at the app root. Instead, each page loads data on mount:
- RecordsPage calls `loadConnections()` (guarded by `loaded` flag)
- ConnectPage calls `initSession()` then `loadConnections()`

This means navigating between pages doesn't re-fetch (because `loaded` stays `true`), but the first page load always hits IndexedDB. This is fine.

**Verdict:** ✅ No changes needed.

---

### StatusMessage.tsx (lines 1–17)

Pure presentational component. Takes `status` and `message` props. No state, no effects. ✅

---

### ProviderSearch.tsx (lines 1–55)

**Local state:** `value` (input text) — debounced with `useEffect` + `setTimeout`.

**Verdict:** ✅ Correct. Search input state is inherently local.

---

### ProviderCard.tsx (lines 1–32)

Pure presentational component. No state, no effects. ✅

---

### lib/storage.ts (lines 1–215)

**Used by:**
- `store/session.ts` — heavily (but session store is dead)
- `ProviderSelectPage.tsx` — `loadSession()` (line 155), `saveOAuthState()` (line 156)
- `OAuthCallbackPage.tsx` — `loadOAuthState()` (line 53), `clearOAuthState()` (line 60)

**Analysis:**
- **Session persistence** (`saveSession`, `loadSession`, `clearSession`, `markSessionFinalized`): Only used by the dead `session.ts` store and ProviderSelectPage's `loadSession()` call. After fixing ProviderSelectPage, these become dead.
- **Provider data persistence** (`addProviderData`, `getFullData`, `loadProviderData`, `getProvidersSummary`): Only used by the dead `session.ts` store. Dead.
- **OAuth state** (`saveOAuthState`, `loadOAuthState`, `clearOAuthState`): Actively used by ProviderSelectPage and OAuthCallbackPage. These use `sessionStorage` (not `localStorage`) and are transient by design. **KEEP these.**
- **IDB helpers** (`openDB`, `idbPut`, `idbGet`, `idbDelete`): Only used by the dead provider data functions. Dead.
- **Cleanup functions** (`clearAllData`, `clearHealthData`): Only used by dead session store. Dead.

**Verdict:** After migration, this file should be gutted to only export: `OAuthState` type, `saveOAuthState`, `loadOAuthState`, `clearOAuthState`.

---

### lib/connections.ts (lines 1–377)

The NEW persistence layer used exclusively by `store/records.ts`. Uses a separate IndexedDB database (`health_skillz_connections`). Manages `SavedConnection` objects and `CachedFhirData`.

**Verdict:** ✅ Active and correct. No changes needed.

---

### lib/api.ts (lines 1–304)

API client used by `store/records.ts` and `ProviderSelectPage.tsx` (for `getVendorConfigs()`).

**Verdict:** ✅ Active. No state management concerns.

---

## 3. Specific Problems (with line numbers)

### P1 (HIGH) — OAuthCallbackPage split-brain status
- **File:** `src/client/pages/OAuthCallbackPage.tsx`
- **Lines:** 25–27 (local state declarations), 115–117 (merge logic)
- **Issue:** `localStatus`, `errorMsg`, and `done` duplicate information tracked by the records store (`store.status`, `store.statusMessage`, `store.error`). The `||` merge on line 117 causes stale text to flash when the store resets `statusMessage` to `''` before local state catches up.
- **Fix:** Add an `oauthStatus` field to the records store (or use existing `status`/`statusMessage`), and read everything from the store. Remove `localStatus` and `done`. Keep `errorMsg` only for OAuth-specific errors that happen before the store is involved (e.g., missing code param).

### P2 (HIGH) — ProviderSelectPage reads from old localStorage
- **File:** `src/client/pages/ProviderSelectPage.tsx`
- **Line:** 155
- **Issue:** `const session = loadSession()` reads from `localStorage` (old persistence), then passes `session?.publicKeyJwk` into the OAuth state. The records store's `session.publicKeyJwk` (from `initSession` → server fetch) is the real source of truth. If `localStorage` has stale data from a previous session, the wrong public key gets saved for OAuth.
- **Fix:** Import `useRecordsStore` and read `store.session?.publicKeyJwk` instead of `loadSession()?.publicKeyJwk`.

### P3 (MEDIUM) — ConnectPage + RecordsPage double-load race
- **File:** `src/client/pages/ConnectPage.tsx`
- **Line:** 23 (`store.loadConnections()` inside `.then()`)
- **Also:** `src/client/pages/RecordsPage.tsx` line 34 (`if (!s.loaded) s.loadConnections()`)
- **Issue:** ConnectPage calls `loadConnections()` after `initSession()` resolves. RecordsPage (rendered as child) also calls `loadConnections()` guarded by `!s.loaded`. If the RecordsPage effect fires before the ConnectPage `.then()`, both run concurrently.
- **Fix:** Remove `store.loadConnections()` from ConnectPage. Let RecordsPage's guarded call be the single entry point. OR: move `loadConnections` into `initSession` itself so it's atomic.

### P4 (MEDIUM) — ProviderSelectPage re-fetches brand data on every visit
- **File:** `src/client/pages/ProviderSelectPage.tsx`
- **Lines:** 34–36 (local state for items/vendors), 48–91 (useEffect that fetches)
- **Issue:** ~5MB brand file is re-fetched every time the user navigates to this page. On slow connections, this causes a multi-second loading spinner each time.
- **Fix:** Cache vendor configs and brand items in the records store (or a separate brands store). Only re-fetch if cache is empty.

### P5 (LOW) — RecordsPage subscribes to entire store
- **File:** `src/client/pages/RecordsPage.tsx`
- **Line:** 25
- **Issue:** `const s = useRecordsStore()` subscribes to ALL state changes. Any mutation (e.g., `statusMessage` changing during upload progress) re-renders the entire page including all connection cards.
- **Fix:** Use Zustand selectors: `useRecordsStore(s => s.connections)`, etc. Or use `useShallow` for object slices.

### P6 (LOW) — ConnectPage useEffect missing store deps
- **File:** `src/client/pages/ConnectPage.tsx`
- **Lines:** 18–31
- **Issue:** References `store.session` in the condition but `store` isn't in deps. The `[sessionId]` dep means the effect only re-runs when the URL param changes, which is correct behavior. But ESLint would flag this.
- **Fix:** Extract `store.session?.sessionId` before the effect and include it in deps, OR use `useRecordsStore.getState()` inside the effect.

---

## 4. Migration Plan

### Phase 1: Delete Dead Code (zero risk)
1. **Delete `src/client/store/session.ts`** — zero runtime imports.
2. **Gut `src/client/lib/storage.ts`** — keep ONLY:
   - `OAuthState` interface
   - `saveOAuthState()`
   - `loadOAuthState()`
   - `clearOAuthState()`
   - Remove all session persistence (`saveSession`, `loadSession`, `clearSession`, `markSessionFinalized`, `getProvidersSummary`)
   - Remove all provider data functions (`addProviderData`, `getFullData`, `loadProviderData`)
   - Remove all IDB helpers (`openDB`, `idbPut`, `idbGet`, `idbDelete`)
   - Remove `clearAllData`, `clearHealthData`
   - Remove `PersistedSession` and `ProviderData` interfaces

### Phase 2: Fix ProviderSelectPage's `loadSession()` bug (high value, low effort)
1. Add `import { useRecordsStore } from '../store/records'` to ProviderSelectPage.
2. Replace line 155:
   ```diff
   - const session = loadSession();
   + const session = useRecordsStore.getState().session;
   ```
3. Update the OAuth state to use `session?.publicKeyJwk` from the store.
4. Remove `import { loadSession } from '../lib/storage'` (keep `saveOAuthState` import).

### Phase 3: Fix OAuthCallbackPage split-brain (high value, medium effort)
1. Remove `localStatus` and `done` local state.
2. Add a transient `oauthPhase` to the records store: `'idle' | 'exchanging' | 'fetching' | 'done'`.
3. Have the OAuth flow update the store directly:
   - Before token exchange: `store.setOAuthPhase('exchanging')`
   - Before FHIR fetch: `store.setOAuthPhase('fetching')` (or let `saveNewConnection` handle it)
   - After completion: `store.setOAuthPhase('done')`
4. Keep `errorMsg` as local state for pre-store errors (missing code/state params), OR add to store.
5. Derive display from `store.status` + `store.statusMessage` only — no `||` merge.

### Phase 4: Fix ConnectPage double-load (medium value, low effort)
1. Remove `store.loadConnections()` from ConnectPage's `.then()` callback (line 23).
2. Optionally: fold `loadConnections` into the end of `initSession` so session init + data load is one atomic action.

### Phase 5: Cache brand data (nice-to-have)
1. Add `vendors` and `brandItems` to the records store (or a new `useBrandsStore`).
2. Add a `loadBrands` action that fetches + parses brand files only if cache is empty.
3. ProviderSelectPage reads from store instead of local state for `allItems` and `vendors`.
4. `searchResults`, `query`, `page`, `selectedItem`, `connecting` stay as local state (ephemeral UI).

### Phase 6: Zustand selector optimization (nice-to-have)
1. Replace `useRecordsStore()` with targeted selectors in RecordsPage, ConnectPage, OAuthCallbackPage.
2. Example: `const connections = useRecordsStore(s => s.connections)`.

---

## 5. Files/Stores That Can Be Deleted After Migration

| File | Can Delete? | When | Notes |
|------|------------|------|-------|
| `src/client/store/session.ts` | **YES — NOW** | Phase 1 | Zero imports. Completely dead. |
| `src/client/lib/storage.ts` | **PARTIAL** | Phase 1 | Keep only OAuth state helpers (`saveOAuthState`, `loadOAuthState`, `clearOAuthState`). Delete everything else. |

---

## 6. State Flow Diagram (Current vs Target)

### Current:
```
ProviderSelectPage → localStorage (loadSession) → saveOAuthState(sessionStorage)
                                                          ↓
OAuthCallbackPage → loadOAuthState(sessionStorage) → store.saveNewConnection
                  → local useState (status, error, done)     ↓
                  → merged display ←── store.statusMessage   ↓
                                                          IndexedDB (connections.ts)
ConnectPage → store.initSession → .then(loadConnections)    ↑
RecordsPage → store.loadConnections (guarded)               ↑
```

### Target:
```
ProviderSelectPage → store.session.publicKeyJwk → saveOAuthState(sessionStorage)
                                                          ↓
OAuthCallbackPage → loadOAuthState(sessionStorage) → store.saveNewConnection
                  → store.statusMessage (single source)     ↓
                                                          IndexedDB (connections.ts)
ConnectPage → store.initSession (which also loads connections)
RecordsPage → reads store (already loaded)
```
